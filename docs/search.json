[{"path":"index.html","id":"sobre-este-documento","chapter":"Capítulo 1 Sobre este documento","heading":"Capítulo 1 Sobre este documento","text":"Blabla, RMarkdown…","code":""},{"path":"metodologia.html","id":"metodologia","chapter":"Capítulo 2 Metodologia","heading":"Capítulo 2 Metodologia","text":"Trabalhos de estatística costumam ter uma parte de metodologia maior que introdução e resultados. Essa tese não será diferente. metodologia é essencial para garantir reprodutibilidade trabalho, pois, mais que simplesmente apresentar o código utilizado, mostra o passo passo, dores e decisões difíceis que tiveram de ser tomadas para concluir o projeto.O capítulo está organizado em três seções: definição problema, dados e simulações. primeira mostra base matemática problema estudado e escolhas de sintaxe e terminologias. segunda descreve fontes de dados e o processo de coleta, já que base foi construída totalmente zero. terceira mostra como foram planejadas simulações para verificar se solução proposta funciona bem empiricamente.Pode parecer incomum uma seção de definições capítulo de metodologia. entanto, ela é muito importante para discussões que seguem. Como será mostrado mais adiante, pesquisa também apresenta resultados teóricos da solução proposta, mas para apresentá-los é necessário escrever definições objeto matemático que está sendo estudado.Uma decisão mais difícil de tomar na parte teórica foi sobre parte de redes neurais. início projeto de doutorado, pesquisa em redes neurais nos departamentos de estatística era uma novidade, sofrendo até certo preconceito por ser um modelo “caixa-preta”. Com o passar tempo, entanto, área está ficando cada vez mais popular, inclusive com pessoas da graduação fazendo iniciação científica neste tema. Por isso, optou-se por trabalhar nas pontes entre os modelos clássicos de estatística e os modelos de redes neurais, mas sem todos os detalhes técnicos que podem ser encontrados com qualidade em livros didáticos. Espera-se que o conteúdo possa ser utilizado por pessoas interessadas em ensinar redes neurais para estudantes de estatística.Na seção de dados, procurou-se apresentar metodologia de coleta em detalhes. Isso foi feito porque área de raspagem de dados não é comum para estudantes de estatística, existindo até uma percepção entre acadêmicos de que trata-se de uma área separada da estatística. Uma das hipóteses de pesquisa, bem como solução técnica apresentada neste trabalho é justamente uma ponte entre duas áreas, justificando um detalhamento maior dos conceitos.Implementações de raspagem de dados, entanto, são inconstantes. Um site de interesse pode mudar sua estrutura ou simplesmente trocar o Captcha para um reCaptcha da noite para o dia, alterando completamente o fluxo de coleta. Isso aconteceu, inclusive, com um dos sites mais importantes dentro contexto da jurimetria: em 2018, o Tribunal de Justiça de São Paulo (TJSP) passou utilizar o reCaptcha para bloquear ferramentas automatizadas. Qualquer código ou fluxo para acessar fontes de dados consideradas trabalho, portanto, estariam datadas momento da publicação. Por isso, optou-se por apresentar essa parte de forma genérica e deixar atualizações para os códigos, que estão disponíveis publicamente e serão mantidos com contribuições da comunidade.Na seção de simulações, procurou-se descrever os passos dados em detalhe. Nesse caso, escolha detalhamento se deu por motivos puramente científicos, para que qualquer pessoa possa reproduzir os passos dados. Dessa forma, pessoas interessadas na área podem replicar os resultados em outros exemplos com alterações mínimas fluxo, além de sugerir melhorias.","code":""},{"path":"metodologia.html","id":"definição-do-problema","chapter":"Capítulo 2 Metodologia","heading":"2.1 Definição do problema","text":"O problema ser trabalhado é um caso de aprendizado fracamente supervisionado. Trata-se de uma generalização aprendizado supervisionado e também aprendizado semi-supervisionado. Usualmente, área de aprendizado estatístico (ou aprendizado de máquinas) se concentra em dois tipos de problemas principais: o aprendizado supervisionado e o aprendizado não supervisionado. É possível observar essa classificação em diversos livros-texto da área (XXX). Isso ocorre principalmente por fins didáticos, pois é mais fácil passar os modelos que fazem parte de cada área.entanto, estatística evolui com os problemas que ocorrem mundo. E, mundo, os problemas nem sempre recaem em uma ou outra categoria. O que temos, na verdade, é que os problemas não supervisionados e supervisionados estão conectados, desde que o objetivo de uma pesquisa seja o de predizer valores (regressão) ou categorias (classificação).Nesse sentido, uma área que ficou popular nos últimos anos, até por conta dos avanços na área de Deep Learning, é o aprendizado semi-supervisionado. Trata-se de uma classe de problemas contendo uma amostra completamente anotada e uma amostra sem anotações. amostra sem anotações é usada para compreender como os dados foram gerados, e os parâmetros podem ser compartilhados com parte supervisionada modelo. Isso poderia indicar que existem três classes de problemas: o não supervisionado, o supervisionado e o semi-supervisionado.Mas isso também não representa todas classes de problemas. Em muitas aplicações reais, obter uma anotação completa e correta pode ser custoso ou até impraticável. Além disso por envolver trabalho humano, é comum que classificações contenham erros. Para lidar com esses casos existe uma área, que generaliza anteriores, que é o aprendizado fracamente supervisionado.O problema fracamente supervisionado será o final da jornada. Ela começa de onde deve começar, com aqueles que são objeto de análise deste trabalho: os Captchas.","code":""},{"path":"metodologia.html","id":"captcha","chapter":"Capítulo 2 Metodologia","heading":"2.1.1 Captcha","text":"Captcha é um desafio tipo desafio-resposta usado para determinar se usuário sistema é um humano. Existem diversos tipos de Captcha diferentes, que envolvem desde identificar textos em imagens até resolver expressões matemáticas complexas.O foco deste trabalho reside nos Captchas baseados em imagens rotuladas, que é o tipo mais comum. Em seguida, menos que se mencione ao contrário, todos os Captchas apresentados são desse tipo.O fluxo completo de um Captcha envolve cinco componentes: um rótulo, um gerador, uma imagem, um agente e um oráculo. Um ciclo Captcha é completado ao seguir os passos:O rótulo é definido, usualmente com algum procedimento aleatório, ocultado agente.imagem é gerada partir rótulo e apresentada para o agente.O agente preenche sua resposta partir da imagem (que pode estar certo ou errado)O oráculo verifica se resposta está correta.Dependendo da resposta, o agente é direcionado para página autenticada ou para uma página de erro.Figura 2.1 esquematiza o fluxo Captcha.\nFigura 2.1: Fluxo Captcha\n","code":""},{"path":"metodologia.html","id":"imagem-rótulo-e-variável-resposta","chapter":"Capítulo 2 Metodologia","heading":"2.1.1.1 Imagem, rótulo e variável resposta","text":"imagem é uma matriz \\(\\mathbf x = \\{x_{nmr} \\[0,1]\\}_{N\\times M \\times R}\\), contendo padrões que, partir da análise humana, levam ao rótulo Captcha. O rótulo dado por um vetor de caracteres \\(\\mathbf c = [c_1,\\dots,c_L]^\\top\\). O comprimento \\(L\\) pode ser fixo ou variável, ou seja, duas imagens criadas pelo mesmo gerador podem vir com comprimentos diferentes. Nas definições que seguem vamos considerar \\(L\\) como fixo, por simplicidade.Os elementos vetor \\(\\mathbf c\\) fazem parte de um alfabeto \\(\\mathcal \\), com cardinalidade \\(|\\mathcal |\\), finito e conhecido. O alfabeto contém todos os possíveis caracteres que podem aparecer na imagem. Na maioria dos casos, \\(\\mathcal \\) corresponde uma combinação de algarismos arábicos (0-9) e letras alfabeto latino (-z), podendo diferenciar ou não letras maiúsculas e minúsculas1.O elemento da matriz \\(x_{nm\\cdot}\\) é denominado pixel. Um pixel representa menor unidade possível da imagem. Em uma imagem colorida, por exemplo, \\(R=3\\). Nesse caso, um pixel é um vetor de três dimensões com valores entre zero e um, representando intensidade de vermelho, verde e azul da coordenada \\((n, m)\\) da imagem. Em imagens em escala de cinza, \\(R=1\\) e o pixel, de uma dimensão, representa intensidade cinza, sendo 1 o equivalente da cor branca e 0 da cor preta.Figura 2.2 mostra um exemplo Captcha Tribunal de Justiça de Minas Gerais (TJMG). Nesse caso, tem-se \\(L=5\\) e \\(|\\mathcal |=10\\), apenas os dez algarismos arábicos. imagem tem dimensões \\(N=110\\), \\(M=40\\) e \\(R=3\\). O rótulo da imagem é \\([5,2,4,3,2]^\\top\\).\nFigura 2.2: Exemplo de Captcha TJMG.\nvariável resposta é uma matriz binária \\(\\mathbf y_{L \\times |\\mathcal |}\\), em que cada linha representa um dos valores vetor \\(\\mathbf c\\), enquanto colunas possuem um representante para cada elemento de \\(\\mathcal \\). Um elemento \\(y_{ij}\\) vale 1 se o elemento \\(\\) rótulo \\(\\mathbf c\\) corresponde ao elemento \\(j\\) alfabeto \\(\\mathcal \\), valendo zero caso contrário. variável resposta pode ser pensada também como o one-hot encoding rótulo.Uma maneira alternativa de definir variável resposta seria com um vetor de índices representando cada elemento alfabeto em um vetor. O problema de trabalhar dessa forma é que variável resposta \\(\\mathbf y\\) tem um número exponencial de combinações: o rótulo possui \\(L\\) caracteres, sendo que cada caractere pode ter \\(|\\mathcal |\\) valores, totalizando \\(|\\mathcal |^L\\) combinações.Por exemplo, um Captcha com \\(L=6\\) letras e \\(|\\mathcal | = 36\\) possibilidades em cada letra (26 letras alfabeto latino e 10 algarismos arábicos), possui um total de 2.176.782.336 (\\(>\\) 2 bilhões) combinações. Por isso, modelar imagens diretamente através de uma única variável resposta categórica é tecnicamente inviável.forma one-hot da resposta pode ser entendida como uma multinomial multivariada (XXX). resposta é multivariada porque temos \\(L\\) caracteres na imagem e multinomial porque temos \\(|\\mathcal |\\) possíveis caracteres em cada posição. Dessa forma, podemos pensar que um modelo que resolve o Captcha envolve \\(L\\) classificadores com resposta multinomial, cada um dando conta de um dos caracteres. Os classificadores podem ser independentes e podem até contar com etapas de pré-processamento separadas.Seguindo o exemplo da Figura 2.2, é possível representar o rótulo da seguinte forma:\\[\n\\mathbf c = \\left[\\begin{array}{c}\n     5  \\\\\n     2 \\\\\n     4 \\\\\n     3 \\\\\n     2\n\\end{array}\\right] \\rightarrow \\mathbf{y} = \\left[\\begin{array}{cccccccccc}\n    0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\\end{array}\\right]\n\\]forma dummy da resposta facilita os trabalhos que seguem. Como será visto mais adiante, o modelo de rede neural gerará uma matriz de probabilidades que somam \\(1\\) em cada linha, com probabilidades de cada caractere em cada posição.","code":""},{"path":"metodologia.html","id":"gerador","chapter":"Capítulo 2 Metodologia","heading":"2.1.1.2 Gerador","text":"O gerador é uma função \\(g\\) que recebe um rótulo como entrada e devolve uma imagem como saída. Um bom gerador é aquele que é capaz de gerar uma imagem fácil de interpretar por humanos, mas difícil de se resolver por máquinas.Um exemplo de gerador é função criada pacote captcha. função foi criada para realizar simulações sistema de resolução proposto na tese, partir pacote magick (XXX), que utiliza o software ImageMagick. função aplica uma série de distorções e efeitos comuns contexto de Captchas, gerando imagens como da Figura 2.3.\nFigura 2.3: Exemplo de captcha gerado pela função captcha::captcha_generate()\nO gerador segue os passos abaixo, partir momento em que um rótulo \\(\\mathbf c\\) existe:É criada uma matriz \\(N\\times M \\times R\\), com valores entre zero e um gerados por simulações de uma \\(\\mathcal U(0,1)\\).É adicionada uma cor base ao ruído, definida de forma aleatória.matriz é transformada em um objeto tipo magick-image.imagem é preenchida com o valor rótulo, adicionando-se efeitos como rotação, linha unindo letras e variação de cores.imagem recebe outros tipos de distorções, como adição de ruído, alteração de cores e outros efeitos.final, o gerador retorna imagem, que é única informação enviada ao agente. O rótulo fica escondido para verificação oráculo.","code":""},{"path":"metodologia.html","id":"oráculo","chapter":"Capítulo 2 Metodologia","heading":"2.1.1.3 Oráculo","text":"Para definir o oráculo, utilizou-se uma terminologia que é facilmente encaixada com teoria de aprendizado fracamente supervisionado. Seja \\(g\\) um modelo utilizado para predizer o valor de uma imagem e seja \\(\\mathbf x_{n+1}\\) uma nova imagem que é observada, com sua resposta \\(\\mathbf y_{n+1}\\), desconhecida. operação \\(g(\\mathbf x_{n+1}) = \\hat {\\mathbf y}_{n+1}\\) retorna um candidato para \\(\\mathbf y_{n+1}\\), que pode estar correto ou errado.O oráculo é uma função \\(\\mathcal O: \\mathcal Y \\rightarrow 2^{\\mathcal Y}\\), ou seja, uma função que recebe um elemento domínio da resposta \\(\\mathcal Y\\) (ou seja, conjunto de todas combinações de rótulos) para o conjunto de subconjuntos (partes) de \\(\\mathcal Y\\). Ou seja, função retorna uma lista de possíveis valores de \\({\\mathbf y}_{n+1}\\). O oráculo funciona da seguinte forma:\\[\n\\mathcal O(\\hat {\\mathbf y}_{n+1}) = \\left\\{\\begin{array}{ll}\n    \\{\\mathbf y_{n+1}\\}, & \\text{ se } \\mathbf y_{n+1} = \\hat {\\mathbf y}_{n+1}  \\\\\n    \\mathcal Y \\setminus \\{\\hat {\\mathbf y}_{n+1}\\}, & \\text{ se } \\mathbf y_{n+1} \\neq \\hat {\\mathbf y}_{n+1}\n\\end{array}\\right.\n\\]Explicando função: quando função \\(g\\) acerta o rótulo, o oráculo retorna uma lista que contém apenas um elemento: o próprio rótulo. Quando função \\(g\\) retorna o rótulo errado, o oráculo retorna uma lista com todos os outros possíveis rótulos para \\(\\mathbf x_{n+1}\\), o que inclui o próprio \\(\\mathbf y_{n+1}\\). É importante notar que lista retornada pelo oráculo sempre contém resposta \\(\\mathbf y_{n+1}\\).Figura 2.4 mostra o funcionamento oráculo exemplo TJMG. Quando predição é igual ao rótulo, o resultado apresentado é o valor um, indicando que o rótulo está correto. Quando predição é diferente rótulo, o resultado apresentado é o valor zero, indicando que o valor testado está incorreto e que, portanto, o rótulo real é um dentre todos os outros possíveis rótulos.\nFigura 2.4: Esquema mostrando o funcionamento oráculo.\nÉ possível generalizar naturalmente o oráculo para múltiplos chutes mudando definição da função que faz predições. Seja \\(h\\) uma função que retorna um conjunto de \\(k\\) respostas possíveis, \\(k\\\\mathbb N\\), \\(k\\geq 1\\), com \\(\\mathbf x_{n+1}\\) e \\(\\mathbf y_{n+1}\\) iguais aos definidos definidos anteriormente. Então o oráculo tem o funcionamento definido abaixo:\\[\n\\mathcal O(h(\\mathbf x_{n+1})) = \\left\\{\\begin{array}{ll}\n    \\{\\mathbf y_{n+1}\\}, & \\text{ se } \\mathbf y_{n+1} \\h(\\mathbf x_{n+1})  \\\\\n   \\mathcal Y \\setminus h(\\mathbf x_{n+1}), & \\text{ se } \\mathbf y_{n+1} \\notin h(\\mathbf x_{n+1})\n\\end{array}\\right..\n\\]Nesse caso, o oráculo também retorna uma lista com resposta \\(\\mathbf y_{n+1}\\). única diferença é que, quando o Captcha aceita múltiplos chutes, lista retornada em caso de erro tem um comprimento menor.O oráculo tem um papel fundamental na solução proposta. O fato oráculo sempre retornar resposta correta na lista de opções faz com que ela necessariamente reduza o espaço de respostas serem buscadas em uma tentativa futura. Esse fato será explorado partir de um método iterativo para encontrar o valor real rótulo.","code":""},{"path":"metodologia.html","id":"fatos-estilizados","chapter":"Capítulo 2 Metodologia","heading":"2.1.1.4 Fatos estilizados","text":"Captchas costumam ter dimensões relativamente pequenas, com altura \\(N\\) variando entre 30 e 200 pixels e largura \\(M\\) variando entre 100 e 300 . imagens costumam ser retangulares para comportar várias letras lado lado, ou seja, geralmente \\(M > N\\). O valor de \\(R\\) é 1 para imagens em escala de cinza e 3 para imagens coloridas.Historicamente, uma alternativa para resolver Captchas é separando o problema em duas tarefas: segmentar e classificar. tarefa de segmentação consiste em receber uma imagem com várias letras e detectar pontos de corte, separando-em várias imagens de uma letra. Já classificação consiste em receber uma imagem com uma letra e identificar o caractere correspondente. Nesse caso, resposta é reduzida para \\(|\\mathcal |\\) categorias, que cresce linearmente e, portanto, tratável.tarefa de resolver Captchas também poderia ser vista como um problema de reconhecimento óptico de caracteres (Optical Character Recognition, OCR). entanto, distorções encontradas em Captchas são bem diferentes das distorções encontradas em textos escaneados, que são o objeto de aplicação de ferramentas de OCR. Por esse motivo, ferramentas usuais de OCR apresentam resultados pouco satisfatórios em vários Captchas.distorções encontradas em Captchas podem ser agrupadas em distorções para dificultar segmentação e distorções para dificultar classificação. Na parte de classificação, principais formas de dificultar o trabalho dos modelos são ) mudar fontes (serifa ou sem serifa ou negrito/itálico, por exemplo), ii) mudar letras minúsculas para maiúsculas e iii) adicionar distorções nos caracteres. Já na parte de segmentação, principais formas são ) colar os caracteres e ii) adicionar linhas ligando os dígitos. Essas técnicas são combinadas com adição de ruído e distorção nas imagens completas para compor imagem final.TODO","code":""},{"path":"metodologia.html","id":"redes-neurais","chapter":"Capítulo 2 Metodologia","heading":"2.1.2 Redes neurais","text":"abordagem discutida ao longo da tese utiliza redes neurais convolucionais. Para explicar o funcionamento dessa técnica, apresenta-se definições para redes neurais e para operação de convolução contexto de Captchas, construindo o modelo utilizado nas simulações modelo proposto.ideia abaixo é apresentar como funcionam redes neurais contexto de Captchas. O modelo apresentado é o que foi utilizado nas simulações, que é um modelo de redes neurais convolucionais simples, similar ao LeNet, com três camadas convolucionais e duas camadas densas (XXX).técnica proposta pela tese pode utilizar diversas arquiteturas de redes neurais. escolha de uma arquitetura mais simples foi feita para demonstrar eficácia procedimento de forma mais contundente. Outras arquiteturas mais rebuscadas, como apresentadas referencial teórico (XXX) podem melhorar aplicação modelo. única restrição é que ela possa receber uma função de perda modificada, como será mostrado seguir.É possível organizar estrutura de uma rede neural em três componentes: arquitetura da rede, função de perda e o otimizador. Os componentes são detalhados nas próximas subseções.Como uma rede neural possui muitos componentes e subcomponentes, é usual apresentar sua estrutura na forma de um diagrama. Redes neurais costumam ser fáceis de representar através de grafos, que podem ser utilizados de forma mais ou menos detalhada, dependento interesse.Figura 2.5 mostra, de forma esquemática, os componentes (retângulos tracejados) e subcomponentes (partes internas dos componentes) modelo utilizado.\nFigura 2.5: Diagrama representando o modelo utilizado de forma genérica, com todos os componentes e subcomponentes apresentados de forma esquemática. partes de fora dos componentes são entradas de dados ou decisões de parada ajuste.\n","code":""},{"path":"metodologia.html","id":"arquitetura-da-rede","chapter":"Capítulo 2 Metodologia","heading":"2.1.2.1 Arquitetura da rede","text":"arquitetura da rede é uma função que leva os dados de entrada na estrutura de dados da variável resposta. arquitetura tem papel similar ao exercido pelo componente sistemático em um modelo linear generalizado (XXX). Trata-se da parte mais complexa da rede neural, carregando todos os parâmetros que serão otimizados.arquitetura da rede possui três componentes principais, separados em dois itens cada:camadas ocultas: camadas convolucionais e camadas densas;técnicas de regularização: normalização em lote (batch normalization), dropout e junção de pixels (max pooling);funções de ativação: função de ativação linear retificada (rectified linear unit, ReLU) e função de normalização exponencial (softmax).Abaixo, apresenta-se definições seguindo-se ordem de aplicação das operações na arquitetura da rede neural: camada convolucional, ReLU, max pooling, batch normalization, dropout, camada densa e softmax.convolução é uma operação linear que recebe como entrada uma matriz e retorna outra matriz. Ela é diferente de uma operação usual de multiplicação de matrizes vista contexto de modelos lineares generalizados, por envolver uma operação nos elementos na vizinhança de cada pixel.Uma forma organizada de fazer essa soma ponderada é criando uma matriz de pesos. Com ela, não é necessário procurar os pontos da vizinhança. Para cada ponto \\((,j)\\), obtem-se matriz de vizinhança, multiplica-se pontualmente pela matriz de pesos e soma-se os valores resultantes. matriz de pesos é chamada de núcleo, ou kernel.Considere\\[\nK = \\left[\\begin{array}{rrr}-1&-1&-1\\\\0&0&0\\\\1&1&1\\end{array}\\right]\n\\]\ne imagem da Figura 2.6. Como visto anteriormente, trata-de de uma matriz de dimensão \\(40\\times110\\times3\\).\nFigura 2.6: Imagem de Captcha utilizado em exemplos anteriores.\nTome por exemplo primeira dimensão pixel \\((,j,k) = (12,16,1)\\). vizinhança 3x3 em torno desse ponto é dada por\\[\nP_{,j,k} = \\left[\\begin{array}{rrr}\n0.094 & 0.412 & 0.686 \\\\\n0.051 & 0.063 & 0.529 \\\\\n0.071 & 0.000 & 0.086\n\\end{array}\\right]\n\\]operação de convolução é feita da seguinte forma:\\[\n\\begin{aligned}\n(P_{12,16,1} *K )_{12,16,1}\n&= k_{1,1}p_{11,15,1} + k_{1,2}p_{11,16,1} + k_{1,3}p_{11,17,1} + \\\\\n&+ k_{2,1}p_{12,15,1} + k_{2,2}p_{12,16,1} + k_{2,3}p_{12,17,1} + \\\\\n&+ k_{3,1}p_{13,15,1} + k_{3,2}p_{13,16,1} + k_{3,3}p_{13,17,1}\n\\end{aligned}\n\\]Esse é o valor ser colocado ponto \\((,j,k)\\). Isso funciona em todos os pontos que não estão na borda da imagem.Existem duas formas de trabalhar com bordas da imagem. primeira é preenchendo bordas com zeros, de forma considerar apenas os pontos da imagem. segunda é descartar os pontos da borda e retornar uma imagem menor, contendo somente os pixels em que foi possível aplicar todo o kernel.caso exemplo, o resultado da convolução fica como na Figura 2.7. matriz não foi escolhida por acaso: ela serve para destacar padrões horizontais da imagem. Como primeira linha é formada por \\(-1\\) e última é formada por \\(1\\), matriz fica com valor alto se parte de cima pixel preta e parte de baixo branca (\\(\\text{grande} * 1 + \\text{pequeno} * (-1)\\)). parte destacada da imagem acabou sendo parte de baixo dos números e, principalmente, linha que une os números.\nFigura 2.7: Aplicação de uma convolução com kernel horizontal.\nAplicando o kernel vertical abaixo\\[\nK = \\left[\\begin{array}{rrr}-1&0&1\\\\-1&0&1\\\\-1&0&1\\end{array}\\right],\n\\]partes destacadas são laterais dos números, conforme Figura 2.8.\nFigura 2.8: Aplicação de uma convolução com kernel horizontal.\nO resultado da convolução pode ter números negativos ou maiores que um. Para que seja possível visualizar, imagens mostradas acima foram normalizadas.Uma característica das imagens mostradas acima é que elas ficaram escuras, ou seja, com muitos valores próximos de zero. Uma técnica para modificar imagem é adicionar uma constante numérica ao resultado da convolução. Esse é o chamado viés (bias) da convolução.Figura 2.9 mostra o efeito de adicionar um viés de 0.6 após aplicação da convolução com kernel vertical. É possível idenificar claramente diferença entre os números (mais suaves) e curvas usadas para conectar os números (mais proeminetes).\nFigura 2.9: Aplicação de uma convolução com kernel horizontal.\nUma camada convolucional envolve aplicação de convoluções com \\(d\\) kernels em uma matriz, além da adição bias. O resultado da aplicação de uma camada convolucional com preenchimento das bordas é uma matriz com mesmas dimensões \\(N\\) e \\(M\\) da matriz de entrada, mas com \\(d\\) entradas na dimensão das cores. Como o valor de \\(d\\) pode ser diferente de 1 ou 3, não faz mais sentido tratar essa dimensão como cores, por isso essa dimensão é chamada de canais da imagem resultante.É importante notar que, nos exemplos apresentados anteriormente, convolução foi aplicada apenas um dos canais da imagem: o primeiro. Quando imagem de entrada possui vários canais, camada convolucional aplica cada kernel em cada canal da imagem e, depois, faz soma dos valores resultantes.Figura 2.10 mostra um exemplo de aplicação de camada convolucional para imagem utilizada nos exemplos anteriores. Os kernels foram escolhidos com base em um modelo que já foi ajustado para o Captcha. Note que os canais capturam informação dos números e dos ruídos, focando em detalhes diferentes.\nFigura 2.10: Resultado da aplicação da primeira convolução à imagem.\nAntes da aplicação da camada convolucional, operação de batch normalization foi aplicada. Essa operação nada mas faz que normalizar os números da matriz de entrada antes da aplicação da convolução, ou seja, retirar média e dividir pelo desvio padrão.\\[\nx_z = \\left(\\frac{x-\\bar x}{\\sqrt{\\sigma^2_x + \\epsilon}}\\right) \\gamma + \\beta\n\\]O valor \\(\\epsilon\\), geralmente um valor pequeno, é adicionado para evitar problemas numéricos quando variância é muito baixa. Os parâmetros \\(\\gamma\\) e \\(\\beta\\) podem ser adicionados passo da normalização, fazendo parte fluxo de aprendizagem modelo. Apesar de não ser uma teoria fechada, alguns resultados (XXX, Sergey Ioffe, Christian Szegedy 2015) indicam que o uso de batch normalization reduz o tempo de aprendizado dos modelos. O passo foi adicionado nos modelos por apresentar bons resulados nas simulações.Após aplicação da convolução, também é aplicada função não linear ReLU. transformação ReLU é mais simples das funções da ativação, sendo igual à função identidade quando entrada é positiva e zero caso contrário:\\[\n\\text{ReLU}(x) = x\\mathbb I_{(x>0)}.\n\\]função ReLU serve para tornar arquitetura modelo uma operação não linear. Qualquer operação não linear poderia ser utilizada, mas mais simples e mais popular é ReLU.Em seguida, aplica-se uma operação para reduzir dimensão da imagem, chamada max pooling. Trata-se de uma operação que recebe imagem e um kernel, retornando, para cada janela, o maior valor dos pixels. Usualmente, técnica também utiliza strides fazendo com que cada pixel seja avaliado apenas uma vez. Por exemplo, para uma matriz com dimensões \\(M_{10\\times10}\\) e kernel com dimensões \\(2\\times2\\), o resultado é uma matriz \\(M^p_{5\\times5}\\) onde cada elemento é o valor máximo da janela correspondente ao pixel.operação max pooling é muito comum contexto de redes neurais convolucionais. Sua aplicação é importante para que os kernels sejam aplicados em diferentes níveis da imagem de entrada.aplicação das camadas convolucionais é repetida três vezes. Ou seja, seguintes operações são aplicadas partir da imagem original:batch normalization: 6 parâmetroscamada convolucional: 896 parâmetrosReLUmax poolingbatch normalization: 64 parâmetroscamada convolucional: 18.496 parâmetrosReLUmax poolingbatch normalization: 128 parâmetroscamada convolucional: 36.928 parâmetrosReLUmax poolingbatch normalization: 128 parâmetrosA dimensão da imagem de entrada, bem como quantidade de canais gerados por cada camada convolucional foram fixadas. Tais números podem ser considerados como hiperparâmetros modelo, mas foram fixados para facilitar simulações, que já contam com diversos hiperparâmetros.imagem de entrada foi fixada na dimensão \\(32\\times192\\). O valor foi definido dessa forma porque um dos Captchas de referência, da Receita Federal Brasil (RFB), possui 6 letras e \\(32*6=192\\). Ou seja, é como se imagem fosse colagem lado lado de 6 imagens \\(32\\times32\\).quantidade de canais gerados pelas camadas convolucionais foram fixadas em 32, 64 e 64. utilização de números crescentes de canais nas camadas convolucionais é comum (XXX), bem como utilização de números que são potências de 2 (XXX). Nesse sentido, um possível valor para terceira camada era de 128 canais, mas optou-se por 64 canais para que quantidade de parâmetros não ficasse grande demais, já que isso exigiria mais tempo de computação e computadores mais poderosos.O total de parâmetros que podem ser otimizados até o final das camadas convolucionais é 56.646. Esse número pode parecer grande contexto de modelos estatísticos tradicionais como uma regressão linear, que teria, considerando cada pixel como uma covariável, 4.401 parâmetros (\\(40\\times110\\) e o intercepto). entanto, é uma quantidade relativamente pequena contexto de redes neurais. Redes neurais recentes aplicadas imagens, como o DALL-E 2 possui 3,5 bilhões de parâmetros (XXX).Em seguida, o resultado é transformado para um formato retangular, similar ao que se encontra em modelos de regressão. Aqui, dimensões da imagem não são mais importantes e os pixels de cada canal são tratados como variáveis preditoras. Esse passo pode ser interpretado da seguinte forma: camadas convolucionais funcionam como um pré-processamento aplicado às imagens, como uma engenharia de variáveis (XXX) otimizada, já que os parâmetros são ajustados modelo.Uma vez obtidas variáveis preditoras com o pré-processamento, é hora de aplicar camadas densas. Tais camadas são mais comuns contexto de redes neurais. Nesse caso, operação linear aplicada é uma multiplicação de matrizes, similar ao que é feito em um modelo linear generalizado. Na verdade, o componente sistemático de um modelo linear generalizado é equivalente uma camada densa com aplicação de viés, com função de ativação da fazendo o papel da função de ligação.Assim como existem os canais das camadas convolucionais, existem os filtros das camadas densas. quantidade de filtros define dimensão vetor de saída. O número de parâmetros da camada densa é igual ao número de itens vetor de entrada multiplicado pelo número de filtros, somado à quantidade de filtros novamente, por conta bias. caso exemplo, saída das camadas convolucionais tem dimensão \\(2\\times22\\times64\\) , ou seja, 64 canais de imagens \\(2\\times 22\\). Com transformação em vetor, quantidade de colunas da base passa ser multiplicação das dimensões, ou 2.816. modelo ajustado que foi utilizado como exemplo, aplicou-se 200 filtros na camada densa, totalizando 563.400 parâmetros. Nas simulações, quantidade de filtros foi variada para produzir modelos com menor ou maior capacidade.É contexto da grande quantidade de parâmetros que entra o conceito dropout (XXX). Trata-se de uma regra de regularização muito simples de implementar, mas que possui grande impacto ajuste dos modelos. técnica consiste em selecionar uma amostra dos parâmetros em uma das camadas e apagá-los, forçando que os valores sejam fixados em zero. Na prática, essa técnica obriga o modelo ser ajustado de forma que amostras aleatórias dos parâmetros sejam boas para predizer variável resposta. Quando o modelo ajustado é usado para inferências, o dropout é desativado e o modelo pode utilizar todos os parâmetros, obtendo-se, na prática, uma média ponderada das predições de cada sub-modelo. Dessa forma, o dropout tem um efeito similar à aplicação da técnica de bagging (XXX), muito utilizada na área de árvores de decisão.O dropout é aplicado após finalização das camadas convolucionais. Em seguida, vem primeira camada densa, um ReLU e um batch normalization. Depois, é aplicada mais um dropout e mais uma camada densa. Com isso, aplicação de operações é finalizada. O total de parâmetros na configuração modelo apresentado foi de 630.496. Os modelos mais simples utilizados nas simulações, com 100 filtros na camada densa, têm 343.696. Os mais complexos, com 300 filtros na camada densa, têm 917.396 parâmetros.Para finalizar arquitetura modelo, quantidades resultantes devem ser ajustadas ao formato da variável resposta. O número de filtros da segunda camada densa precisa ser escolhido cuidadosamente, pois deve ser igual à multiplicação das dimensões da variável resposta. caso TJMG, os rótulos têm comprimento igual 5 e vocabulário de comprimento 10 (algarismos arábicos), organizados em uma matriz \\(5\\times10\\), com 50 entradas. Por isso, quantidade de filtros da última camada densa também é 50, e o vetor de saída é formatado para uma matriz de dimensão \\(5\\times10\\).final, o resultado precisa ser normalizado para que fique mesmo escopo de variação da resposta. resposta possui apenas zeros e uns, sendo que cada linha da matriz tem somente um número “1”, correspondendo ao índice rótulo alfabeto e, nas outras entradas, o valor zero. saída modelo deve, portanto, apresentar números entre zero e um que somam 1 em cada linha.Isso é feito através da função softmax, aplicada cada linha da matriz de saída. função softmax é uma normalização que utiliza função exponencial denominador, forçando que soma dos valores vetor seja um.\\[\n\\text{soft}\\max(y_i) = \\frac{e^{y_i}}{\\sum_{j=1}^{|\\mathcal |} e^{y_j}}\n\\]exemplo, saída modelo é matriz abaixo:\\[\n\\hat{\\mathbf z} = \\left[\\begin{array}{rrrrrrrrrr}\n  -17.54 & -13.52 & -15.49 & -6.67 & -9.91 & 9.94 & -11.40 & -10.93 & -11.84 & -9.31 \\\\\n  -10.93 & -15.62 & 8.31 & -6.59 & -11.08 & -10.37 & -10.06 & -5.83 & -11.43 & -15.17 \\\\\n  -10.54 & -13.67 & -9.61 & -11.46 & 11.28 & -14.35 & -9.91 & -11.37 & -9.91 & -10.02 \\\\\n  -18.19 & -9.60 & -10.96 & 5.35 & -10.15 & -6.63 & -15.56 & -13.34 & -6.87 & -10.86 \\\\\n  -11.36 & -8.73 & 6.46 & -7.05 & -6.14 & -9.26 & -18.98 & -10.36 & -16.11 & -9.67 \\\\\n\\end{array}\\right].\n\\]Note que matriz apresenta valores negativos e positivos. Na primeira linha, por exemplo, o valor positivo está na sexta coluna, correspondendo ao algarismo “5”. De fato, esse é o valor primeiro elemento rótulo para esta imagem. Após aplicação softmax, matriz de predições obtida é matriz abaixo. Mesmo usando cinco casas decimais, na maioria dos casos, o modelo de exemplo aparenta ter confiança nas respostas.\\[\n\\hat{\\mathbf y} = \\left[\\begin{array}{rrrrrrrrrr}\n  0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 1.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 \\\\\n  0.00000 & 0.00000 & 1.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 \\\\\n  0.00000 & 0.00000 & 0.00000 & 0.00000 & 1.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 \\\\\n  0.00000 & 0.00000 & 0.00000 & 0.99999 & 0.00000 & 0.00001 & 0.00000 & 0.00000 & 0.00000 & 0.00000 \\\\\n  0.00000 & 0.00000 & 0.99999 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 & 0.00000 \\\\\n\\end{array}\\right].\n\\]Vale notar que, dependendo da implementação, nem sempre é necessário aplicar função softmax. Em alguns pacotes computacionais como o torch, utilizado nesta tese, normalização pode ser feita diretamente na função de perda, que aproveita expressão completa para realizar algumas simplificações matemáticas e, com isso, melhorar precisão das computações. O uso da função de perda ficará claro na próxima subseção.","code":""},{"path":"metodologia.html","id":"perda","chapter":"Capítulo 2 Metodologia","heading":"2.1.2.2 Perda","text":"TODO","code":""},{"path":"metodologia.html","id":"otimizador","chapter":"Capítulo 2 Metodologia","heading":"2.1.2.3 Otimizador","text":"TODO","code":""},{"path":"metodologia.html","id":"aprendizado-estatístico","chapter":"Capítulo 2 Metodologia","heading":"2.1.3 Aprendizado estatístico","text":"Apresentados o objeto de estudo, redes neurais utilizadas e proposta da pesquisa, passa-se discutir o significado disso tudo contexto de aprendizado estatístico. Essa parte foi escrita para proporcionar base teórica e notação para apresentar propriedades modelo proposto na tese.","code":""},{"path":"metodologia.html","id":"aprendizado-supervisionado","chapter":"Capítulo 2 Metodologia","heading":"2.1.3.1 Aprendizado supervisionado","text":"TODOAs definições seguem mesma terminologia de Cabannes (XXX). Nosso objetivo é obter uma função \\(f \\\\mathcal{Y}^\\mathcal{X}\\) entre um espaço de entrada \\(\\mathcal X\\) e um espaço de saída \\(\\mathcal{Y}\\).Definimos também função de distribuição conjunta \\(\\rho \\\\Delta_{\\mathcal X \\times \\mathcal Y}\\) sobre \\(\\mathcal X \\times \\mathcal Y\\). Essa função nem sempre é apresentada em outros contextos, mas será útil para estudar os modelos fracamente supervisionados.Finalmente, definimos uma função de perda \\(\\ell \\\\mathbb R^{\\mathcal Y \\times \\mathcal Y}\\), que minimiza o risco\\[\n\\mathcal R(f;\\rho) = \\mathbb E_{(X,Y)\\sim\\rho}[\\ell(f(X),Y)]\n\\]Ou seja, o risco é o risco geral, definido como o valor esperado da função de perda sob \\(\\rho\\) para os valores possíveis de \\(X\\) e \\(Y\\).","code":""},{"path":"metodologia.html","id":"aprendizado-fracamente-supervisionado","chapter":"Capítulo 2 Metodologia","heading":"2.1.3.2 Aprendizado fracamente supervisionado","text":"TODOO aprendizado fracamente supervisionado pode ser dividido em três tipos principais. supervisão com erros, supervisão com rótulos incompletos e supervisão de grupos de observações. O caso Captcha pode ser entendido como aprendizado fracamente supervisionado com rótulos incompletos, já que uma parte da base pode ser anotada (supomos que sem erros) e uma parte da base é resposta oráculo indicando uma lista de rótulos possíveis que incluem o correto.Formalmente, o aprendizado fracamente supervisionado é definido como uma generalização aprendizado totalmente supervisionado, como mostrado em seguida.","code":""},{"path":"metodologia.html","id":"método-mucho-loko","chapter":"Capítulo 2 Metodologia","heading":"2.2 Método mucho loko","text":"(TODO)","code":""},{"path":"metodologia.html","id":"dados","chapter":"Capítulo 2 Metodologia","heading":"2.3 Dados","text":"Nesta seção, descreve-se em detalhes como foi obtenção dos dados para realização da pesquisa. Como comentado anteriormente, base foi construída zero para os fins projeto, sendo uma parte significativa dos esforços para obtenção dos achados.total, foram construídas bases de dados de dez Captchas que estavam disponíveis publicamente momento da realização da pesquisa. Os Captchas foram revisados pela última vez dia 14/02/2022, para verificar se ainda estavam ativos.","code":""},{"path":"metodologia.html","id":"escolha-dos-captchas-analisados","chapter":"Capítulo 2 Metodologia","heading":"2.3.1 Escolha dos Captchas analisados","text":"Para selecionar os Captchas, foram adotados alguns critérios objetivos. Os critérios foram:O site acessado é de um serviço público (governo federal, tribunal, etc).O Captcha contém letras (Z) e números (0 9) em uma imagem com extensão jpeg ou png.O comprimento Captcha é fixo, ou seja, dois Captchas da mesma origem devem ter sempre o mesmo comprimento.primeira restrição para escolha dos Captchas é de ordem principiológica. Um serviço público não deveria restringir o acesso aos dados para robôs. Como já discutido anteriormente, nesses casos, existência Captcha não tem como finalidade dar maior segurança ao serviço prestado, mas sim limitar o acesso aos servidores por robôs.restrições 2 e 3 foram escolhidas com o objetivo de facilitar simulações para obtenção dos resultados. Em princípio, nada impede que os modelos desenvolvidos trabalhem com outros tipos de rótulos, desde que exista uma lista prévia de rótulos. Além disso, é possível realizar adaptações pré-processamento base de dados para lidar com diferentes comprimentos de Captchas.Tabela 2.1 mostra os Captchas trabalhados. informação de limite de chutes é importante para implementação oráculo, detalhado seguir.Tabela 2.1: Lista de captchas analisados.Oráculo foi o nome escolhido para possibilidade de checar, de forma automática, se uma predição modelo foi bem ou mal sucedida. Como um Captcha é um teste de Turing inverso, por definição ele é obrigado mencionar se uma predição está correta: se predição foi correta, página de interesse é acessada; se predição está incorreta, o site envia uma mensagem de erro.Para implementar um oráculo em uma linguagem de programação, é necessário seguir os seguintes passos:Acessar página site de interessePreencher o formulário de pesquisa com informação ser consultada. Por exemplo, site da RFB, informação é o CNPJ da empresa ser consultada. Em um site de tribunal, informação é um número identificador de processo.Baixar o Captcha da busca.Aplicar o modelo Captcha baixado (ou classificar imagem manualmente) para obter predição.Submeter consulta site, informando predição.Verificar o resultado. Se acessou página desejada, predição está correta. Caso contrário, predição está incorreta.Outra oportunidade que o oráculo permite em parte dos casos é possibilidade de testar mais de uma predição. Sites com essa caracteística permitem que pessoa ou robô teste mais de uma predição caso o Captcha tenha fracassado. Como é possível observar na Tabela 2.1, dos 10 Captchas trabalhados, 7 permitem realização desses testes.Em teoria, possibilidade de testar vários rótulos para o mesmo Captcha implica na possibilidade teórica de resolver um Captcha por força bruta. Bastaria testar todos os rótulos possíveis para acessar página de interesse. Na prática, entanto, essa estratégia não funciona, já que quantidade de rótulos possíveis é muito grande para testar site, seja por demorar muito tempo ou pelo site forçar troca de Captcha após passagem de determinado tempo ou quantidade de tentativas.Lista e caracterização dos captchasAlém dos Captchas de sites, também consideramos imagens geradas artificialmente para rodar os modelos. O motivo de criar Captchas artificiais é facilidade de rodar modelos e simulações, já que nos casos reais é necessário ter acesso à internet e também construir bases de dados de cada Captcha.Desenvolvemos duas alternativas para o Captcha gerado. O primeiro, chamado MNIST-Captcha, é simplesmente uma adaptação da conhecida base MNIST para ficar formato de um Captcha. partir da escolha comprimento e dos caracteres que fazem parte da imagem, o gerador simplesmente faz uma amostra aleatória da base MNIST e compõe imagens horizontalmente.Figura ?? mostra um exemplo Captcha gerado partir da base MNIST. exemplo, o comprimento escolhido para o Captcha foi de 4 valores.O problema MNIST-Captcha é que base de dados original é finita. Apesar de possuir por volta de 60 mil observações e de um Captcha crescer em ordem exponencial, o MNIST-Captcha pode gerar Captchas repetidos. Além disso, é necessário tomar cuidado com bases de treino e teste, já que os elementos de teste não poderiam fazer parte de nenhuma observação de treino.Por esse motivo, criamos um Captcha interamente gerado por programação, chamado R-Captcha. O Captcha é gerado utilizando ferramenta ImageMagick, com possibilidade de customizar diversos parâmetros, comoQuais caracteres usar na imagemO comprimento CaptchaDimensões da imagemProbabilidade de rotação da imagemProbabilidade de adicionar um risco entre letrasProbabilidade de adicionar uma borda nas letrasProbabilidade de adicionar uma caixa (retângulo) em torno das letrasProbabilidade de adicionar um ruído branco fundo da imagemProbabilidade de adicionar efeitos de tinta óleo e implosãoPor ser uma versão mais flexível e completa, optamos por trabalhar principalmente com o R-Captcha nas simulações. O MNIST-Captcha foi implementado mas não foi utilizado nas simulações.Repositório de dadosOs Captchas foram classificados com o procedimento que chamamos de semi-automático, definido seguir. pacote captchaDownload, foram desenvolvidas ferramentas para baixar e organizar cada Captcha, utilizando o oráculo para garantir que imagens eram corretamente classificadas.Cada Captcha teve primeiras 100 observações classificadas manualmente. Isso foi feito partir próprio RStudio, utilizando ferramenta de classificação manual pacote captcha.partir das classificações iniciais, um modelo foi ajustado com quantidade de observações disponível. Esse passo também foi feito partir pacote captcha, que cria um projeto de classificação para um Captcha específico.O modelo, então, foi utilizado como uma ferramenta para otimizar classificação manual, funcionando da seguinte forma. Primeiro, o modelo tenta realizar predição automaticamente e o oráculo avisa se predição está correta ou não. Se estiver incorreto, e o site aceitar várias tentativas, o modelo tenta novamente, mas com uma segunda alternativa de predição, definida por uma heurística, definida Capítulo ??. Caso o site não aceite várias tentativas ou o modelo não consiga acertar o Captcha em \\(N\\) tentativas (que arbitramos como dez), imagem Captcha aparecerá para classificação manual.Com o procedimento destacado acima, é criada uma nova base de dados, que por sua vez é utilizada para ajustar um novo modelo. O modelo, atualizado, é utilizado para classificar novos Captchas, e assim por diante, até que o modelo ajustado alcance uma acurácia razoável, que arbitramos em 80%. Com isso, finalizamos o procedimento de classificação.O único problema procedimento de classificação diz respeito aos Captchas que não aceitam várias tentativas. Nesses casos, não é possível verificar com certeza absoluta que um caso classificado manualmente (após tentativa modelo) foi classificado corretamente, já que classificação manual seria segunda tentativa. entanto, esse problema aparece somente em três Captchas (cadesp, jucesp e trf5). classificação manual dos 100 primeiros Captchas, entanto, mostrou que pelo menos 95% dos Captchas foram classificados corretamente quando classificados manualmente. Supomos que proporção máxima de 5% de erro é negligenciável considerando que maior parte das bases de dados foi construída com verificação oráculo.Para este trabalho, desenvolvemos uma técnica inovadora para resolver Captchas sem necessidade de feedback humano. solução envolve avanços em duas direções: engenharia e modelagem.","code":""},{"path":"metodologia.html","id":"construção-dos-dados","chapter":"Capítulo 2 Metodologia","heading":"2.3.2 Construção dos dados","text":"Na parte de engenharia, desenvolvemos uma técnica para capturar e anotar feedbacks automatizados oráculo preenchimento de Captchas. técnica consiste em três passos:Desenvolver um robô que acessa o site desejado e tenta acessar uma informação que exige preenchimento de Captcha.partir de um modelo estatístico inicial, o robô tenta preencher o Captcha automaticamente, submetendo para avaliação site.Se o Captcha verificado pelo site como correto, anotamos o caminho da imagem com o valor “1”. Se estiver incorreto, anotamos o caminho da imagem com o valor “0”.O procedimento descrito pode ser reproduzindo indefinidamente. Isso significa que podemos criar uma base de dados virtualmente infinita de Captchas rotulados, com informação adicional rótulo estar correto ou incorreto. Fizemos isso para todos os Captchas presentes em nossa base de dados.O problema uso de oráculos é que informação adicional recebida quando o modelo erra é incompleta. única informação nova que temos é que o rótulo testado está incorreto, dentre todos os rótulos possíveis daquela imagem. Como temos uma grande quantidade de rótulos possíveis em um Captcha, muitas vezes na ordem de milhões, o feedback oráculo pode ser considerado fraco.Uma possível abordagem para lidar com o segundo problema seria simplesmente descartar os Captchas classificados incorretamente. Podemos criar uma base de dados (virtualmente infinita) somente com os rótulos corretos e ajustar um novo modelo. Essa abordagem, entanto, tem sérios problemas, já que considera somente os casos em que o classificador já funciona bem. Nosso objetivo é melhorar o modelo justamente nos casos em que o oráculo acusa erros.","code":""},{"path":"metodologia.html","id":"análise-descritiva","chapter":"Capítulo 2 Metodologia","heading":"2.3.3 Análise descritiva","text":"Os resultados empíricos foram divididos em dois testes. Primeiro, separamos uma amostra rotulada para verificar o quanto heurística recuperava os valores corretos, partir da predição de um modelo inicial. Depois, verificamos o ganho efetivo na acurácia modelo alimentado com base de dados aumentada, descrita na Seção 2.4.Para o primeiro teste, adotamos o seguinte procedimento. Para cada Captcha, selecionamos bases de treino iniciais que resultaram em acurácias de 40%, 60% e 80% após o ajuste modelo de redes neurais convolucionais. Em seguida, aplicamos heurística nos casos da base de teste em que o modelo errou. Finalmente, calculamos o percentual de recuperação dos resultados pela heurística.parte ajuste modelo de redes neurais convolucionais merece alguns comentários adicionais. Por um lado, é importante que o modelo esteja bem ajustado, para que o erro modelo seja fruto somente da quantidade de observações e não um problema de sub ajuste. Por outro lado, cada tamanho de base pode estar ligada diferentes hiperparâmetros, e não existe uma forma de garantir que os melhores hiperparâmetros foram selecionados.(goodfellow2014?) menciona que, para realizar comparações de modelos, técnicas de regularização, especialmente aumentação de dados, devem ser padronizadas. Por isso, optamos por manter mesma grade de hiperparâmetros em todos os modelos. Especificamente, consideramos na grade quantidades:Multiplicador da quantidade de filtros convolucionais.Quantidade de filtros na primeira camada densa.Dropout.Para diferentes modelos, como AC-GAN, o procedimento seria o mesmo. Bastaria fixar os hiperparâmetros e rodar todos os modelos.Tabela ?? mostra os resultados da análise. É possível verificar que heurística X apresenta os melhores resultados, independentemente Captcha ou da capacidade modelo inicial.Figura ?? mostra os mesmos resultados de forma visual e resumida. É possível notar que proporção de casos recuperados não aumenta linearmenteEm seguida, passamos para segunda etapa procedimento. Nesta etapa, adicionamos base construída pelo oráculo e modificada pela heurística à base de treino inicial. Como base de teste, utilizamos um conjunto de dados novo, que não foi utilizado em nenhum procedimento anterior, para garantir que não há contaminação.","code":""},{"path":"metodologia.html","id":"simulacoes","chapter":"Capítulo 2 Metodologia","heading":"2.4 Simulações","text":"Para verificar o poder uso oráculo para o aprendizado modelo, recorremos uma série de simulações. simulações foram organizadas em três passos: modelo inicial, dados e modelo final. Os passos foram descritos em maior detalhe seguir.","code":""},{"path":"metodologia.html","id":"primeiro-passo-modelo-inicial","chapter":"Capítulo 2 Metodologia","heading":"2.4.1 Primeiro passo: modelo inicial","text":"simulação modelo inicial teve como objetivo obter modelos preditivos de Captchas com acurácias distintas. O modelo inicial seria usado, então, para baixar dados diretamente site usando o oráculo e, por fim, ajustar um modelo final com os novos dados provenientes oráculo.Construímos os modelos iniciais em dois passos. O primeiro foi montar base de dados completa, suficiente para ajustar um modelo com alta acurácia, que arbitramos em 80%, como descrito anteriormente. Depois, montamos 10 amostras de dados com subconjuntos das bases completas, cada uma contendo 10%, 20%, e assim por diante, até base completa. Por exemplo: Captcha da Jucesp, obtivemos um modelo com acurácia maior que 80% com 4000 Captchas. Fizemos então uma partição dos dados com 400 imagens (10% total), 800 imagens (20% total) e assim por diante, até o modelo com 4000 Captchas.Para cada tamanho de amostra \\(\\), rodamos uma bateria de 27 modelos. Fizemos isso porque para diferentes quantidades de amostra, configuração dos hiperparâmetros que resulta melhor modelo pode ser diferente. Fizemos uma grade de hiperparâmetros considerando três informações:quantidade de unidades computacionais na primeira camada densa após camadas convolucionais: consideramos os valores de 100, 200 e 300.O valor dropout aplicado às camadas densas: consideramos os valores de 10%, 30% e 50%.O fator de decaimento na taxa de aprendizado cada época: consideramos os valores de 1%, 2% e 3%.Combinando os três valores dos três hiperparâmetros, temos um total de \\(27=3^3\\) hiperparâmetros. Com isso, foi possível identificar, para cada tamanho de amostra \\(\\), o classificador \\(C_A\\) com melhor acurácia dentre os modelos ajustados.final primeiro passo, portanto, consideramos apenas o melhor modelo para cada tamanho de amostra. É claro que os modelos encontrados por essa técnica não são, necessariamente, os melhor modelo possíveis. entanto, como técnica é mesma para todos os Captchas, ganhamos possibilidade de fazer comparações e temos uma metodologia mais transparente.","code":""},{"path":"metodologia.html","id":"segundo-passo-dados","chapter":"Capítulo 2 Metodologia","heading":"2.4.2 Segundo passo: dados","text":"O segundo passo teve como objetivo construir bases de dados utilizando o oráculo. Primeiro, foi necessário decidir quais modelos, dentre os 10 ajustados para cada Captcha, seriam utilizados para construir novas bases. Não faria sentido, por exemplo, considerar um modelo com acurácia de 0%, já que ele não produziria nenhuma observação comparado com um modelo que chuta aleatoriamente. Também não faria sentido considerar um classificador com acurácia de 100%, já que nesse caso não há o que testar com técnica oráculo.Decidimos que seria necessário considerar somente os modelos que resultaram em acurácias maiores de 1% e menores de 50%. O valor máximo foi decidido após realizar alguns testes empíricos e verificar, informalmente, que técnica oráculo realmente resultava em ganhos expressivos, mesmo com modelos de baixa acurácia. Concluímos então que não seria necessário testar eficácia da técnica para classificadores com alta acurácia. Já o valor mínimo foi decidido de forma arbitrária, retirando-se os classificadores com acurácia muito baixa.segunda decisão ser tomada para construção dos dados foi quantidade de imagens que seria baixada para cada Captcha. Como temos Captchas de diferentes dificuldades, quantidade de dados seria diferente. Optamos por baixar quantidade de dados de forma montar uma base de treino que contém quantidade de observações igual ao melhor modelo daquele Captcha. Por exemplo, TJRS, um modelo com acurácia próxima de 100% foi identificado com 2000 observações. O melhor modelo com 300 imagens (240 para treino, 60 para teste) resultou em uma acurácia de 35%. Foram, então, baixadas 1760 observações para compor o total de 2000 na base de treino. imagens de teste modelo inicial poderiam até ser utilizadas, mas optamos por descartar para garantir que o modelo não ficasse sobreajustado para primeira base.O motivo de baixar mesma quantidade de observações que o melhor modelo inicial foi feita por dois motivos. O primeiro é que temos evidências de que é possível construir um bom modelo com essa quantidade de imagens, ainda que em um caso tenhamos informações completas, e outro incompletas. O segundo é que isso nos permite comparar o resultado modelo completamente anotado contra o modelo que é parcialmente anotado e com anotações incompletas provenientes oráculo.terceira e última decisão tomada para baixar os dados foi quantidade de chutes que o modelo poderia fazer, nos casos em que isso é permitido pelo site. Optamos, de forma arbitrária, por três valores: 1, que é equivalente um site que não permite múltiplos chutes, 5 chutes e 10 chutes.Portanto, o procedimento de coleta dos dados foi feito, para cada Captcha, da seguinte forma:Listamos todos os melhores modelos ajustados para cada tamanho de amostra.Filtramos os modelos para os que apresentavam acurácia de 5% até 50%Definimos o tamanho da base ser obtida, com base tamanho da base de treino utilizada modelo e quantidade total que se objetivou obter.Para cada quantidade de tentativas disponível (1, 5 e 10), baixamos imagens, classificando com o valor “1” se o Captcha fosse classificado corretamente em alguma das tentativas, e com o valor “0” caso contrário.Nos casos com erros, armazenamos um arquivo de log para cada Captcha com o histórico de tentativas incorretas, que é informação mais importante ser passada modelo final.final, obtivemos bases de dados de treino para todos os Captchas analisados, com quantidades de imagens variadas de acordo com os parâmetros definidos anteriormente, variando também pela quantidade de tentativas. quantidade total de bases de dados geradas foi 65.Além das bases de treino, construímos, para cada Captcha, uma base de teste. bases de teste foram construídas completamente zero, sem utilizar informações de bases anteriores. Para construir bases, utilizamos mesma técnica semi-automática definida anteriormente, usando o melhor modelo disponível para classificar maioria das imagens e classificando manualmente em caso de falha. Em alguns casos, como TJMG e TJRS, classificação humana quase não foi necessária, pois os classificadores obtidos apresentaram acurácia próxima de 100%.Como o único objetivo da base de teste foi o de estimar acurácia dos modelos finais, quantidade de observações poderia ser arbitrada. O tamanho das bases de teste foi, então, arbitrado em 1000 imagens para todos os Captchas.","code":""},{"path":"metodologia.html","id":"terceiro-passo-modelo-final","chapter":"Capítulo 2 Metodologia","heading":"2.4.3 Terceiro passo: modelo final","text":"O modelo final foi ajustado para cada uma das 65 bases de treino disponíveis após realização dos passos 1 e 2. Nesse caso, utilizamos o modelo proposto, que considera os erros na verossimilhança modelo. Caso imagem tenha sido corretamente classificada, função de perda é calculada normalmente. Caso ela tenha sido classificada incorretamente, consideramos na verossimilhança probabilidade de não observar nenhum dos chutes.Exemplo. Considere um Captcha com letras e números como vocabulário e comprimento de 4 valores. Uma imagem apresenta o rótulo (correto) “zab2”. O classificador passo inicial tentou seguintes configurações: “zab5”, “sab2”, “sab5”, “zob2”, “zob5”, todas erradas. probabilidade considerada na verossimilhança para essa imagem é, portanto:\\[\nP = 1 - p(\\text{zab5})- p(\\text{sab2})- p(\\text{sab5})- p(\\text{zob2})- p(\\text{zob5})\n\\]Além de modificar forma de calcular função de perda modelo, foi necessário testar os hiperparâmetros. Optamos por utilizar os mesmos hiperparâmetros dos modelos iniciais para manter consistência. O único detalhe nesse ponto é que, como partimos dos parâmetros modelo inicial, optamos por não modificar quantidade de unidades na camada densa, variando somente os valores de dropout e de decaimento na taxa de aprendizado. Portanto, ajustamos 9 e não 27 modelos para cada base de dados.final, assim como primeiro passo, selecionamos classificador com melhor acurácia para cada modelo. Ficamos, então, com 65 modelos final para comparar com os modelos iniciais e estimar efetividade oráculo. comparações foram feitas através de gráficos de barras, explorando o efeito uso oráculo para diferentes Captchas, diferentes modelos iniciais e diferentes quantidades de chutes, além de um gráfico de dispersão para relacionar acurácias iniciais e finais.Além terceiro passo, fizemos alguns experimentos para verificar se, ao aplicar técnica oráculo iterativamente, poderíamos obter melhores resultados. Ou seja, podemos considerar os modelos obtidos passo 3 como os modelos iniciais passo 1, aplicar novamente o passo 2 (baixar dados) e o passo 3 (rodar modelo com os novos dados). Isso foi feito para apenas um conjunto selecionado de Captchas para verificar essa possibilidade, não fazendo parte das simulações principais deste estudo.","code":""}]
